---
description: Python and FastAPI development standards. Apply only to Python/FastAPI projects.
globs: **/*.py, app/**/*, tests/**/*
alwaysApply: false
---

You are an expert in Python, FastAPI, and scalable API development. Follow these rules for Python/FastAPI code generation, refactoring, and suggestions. If the project uses different versions or tools, adapt accordingly.

## Core Principles

- Write concise, technical responses with accurate Python examples.
- Prefer functional, declarative programming; avoid classes unless necessary.
- Favor iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `is_active`, `has_permission`, `can_edit`).
- Use lowercase with underscores for directories and files (e.g., `routers/user_routes.py`).
- **Prefer structured inputs/outputs** (Pydantic models, typed dicts) over raw dictionaries when it improves clarity.
- Handle errors and edge cases at the start of functions with early returns and guard clauses.
- **Use guard clauses** for early returns; keep happy path readable (typically first after guards).
- Keep functions around 30 lines or less; one public class or component per file.
- Write everything in English (identifiers, comments, commit messages, documentation).

## Python & FastAPI Standards

- **Python Version**: Use the project's Python version. Prefer modern features (match statements, type parameter syntax) when available.
- **Type Hints**: Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries.
- **Functions**: Use `def` for pure functions and `async def` for I/O-bound operations (database, APIs, files).
- **Pydantic**: Use for input validation and response schemas. If project uses v1, follow v1 patterns; if v2, leverage validators and computed fields.
- **SQLAlchemy**: Use async engine and sessions when available. Prefer parameterized queries. If project uses v1, adapt accordingly.
- **Error Handling**: Use `HTTPException` for expected errors with specific status codes (400, 401, etc.).
- **Lifespan**: Use lifespan context managers for startup/shutdown instead of `@app.on_event`.
- **Dependency Injection**: Use FastAPI's `Depends` for sessions, auth, and shared resources.

## Project Structure

```
app/
├── main.py              # FastAPI app instance and lifespan
├── api/v1/             # Versioned API routes (use APIRouter)
├── core/               # Config, security, logging
├── models/             # SQLAlchemy ORM models (if used)
├── schemas/            # Pydantic models for validation
├── services/           # Business logic layer
├── repositories/       # Data access layer (optional)
├── utils/              # Utility functions
└── db/                 # Database config and migrations (Alembic)
tests/                  # Mirrored structure for unit/integration/e2e
```

## Error Handling & Validation

- Validate inputs first using Pydantic and guard clauses.
- Log errors with context (operation, parameters, identifiers) at appropriate levels.
- Provide clear, user-friendly error messages; avoid exposing internals.
- Use custom exceptions for domain errors; handle globally via middleware.

## Performance & Scalability

- Use async for all I/O; leverage `asyncio.gather()` for parallel tasks.
- Optimize queries: Use indexes, eager loading, bulk operations; avoid N+1.
- Paginate lists; support filtering, sorting, and field selection.
- **If the project uses caching (Redis/in-memory)**, implement with invalidation strategies.
- **If the project uses background workers (Celery/RQ)**, use them for long-running tasks.

## Security

- Validate all inputs with Pydantic; sanitize user content.
- **If the project handles passwords**, use `passlib` for hashing (bcrypt/argon2).
- **If the project uses JWT/OAuth2**, enforce token expiration and RBAC.
- Store secrets in env vars; never commit `.env` files.
- **If deploying to production**, set security headers (HSTS, CSP), force HTTPS, configure CORS strictly.

## Testing

- Use pytest with `pytest-asyncio` for async tests.
- Follow AAA pattern; name tests as `test_<function>_<condition>_<expected_result>`.
- Use fixtures for test DB (in-memory, rollback transactions).
- Run integration tests with `httpx.AsyncClient`.
- **Aim for good coverage** (target 80%+ for critical paths, adapt to project needs).

## Documentation & Observability

- Add docstrings explaining "why" for public symbols (PEP 257).
- Leverage FastAPI OpenAPI/Swagger; add summaries, descriptions, examples.
- Use structured JSON logging with request/user IDs and metrics.
- Implement health checks (`/health`, `/ready`); track latency, errors.
- Maintain README with setup, architecture, and guides.

## CI/CD & Deployment

- Use Conventional Commits (see [git-commit.mdc](mdc:.cursor/rules/git-commit.mdc)).
- Run linting (Black/Ruff), typing (mypy), tests in CI.
- **If the project uses Docker**, containerize appropriately.
- **If the project uses IaC (Terraform)**, follow project patterns.
- **For production deployments**, use zero-downtime strategies (blue/green) and rollback plans.

## Dependencies & Tooling

- **Use the project's dependency manager** (Poetry, UV, pip-tools, etc.); pin versions in production.
- **Core stack:** Follow project conventions (FastAPI, Pydantic, SQLAlchemy versions as used).
- **Dev tools:** Use project's linting/formatting (Black/Ruff), typing (mypy), testing (pytest) setup.
- **Optional libraries:** Use only if already in project (fastapi-users, python-jose, redis, httpx, etc.).

## AI Assistance Guidelines (Cursor-Specific)

- **Governance**: Respect Cursor docs (https://cursor.com/de/docs/context/rules). Document AI involvement; require human review for all generated code.
- **When to Use AI**: For boilerplate, refactoring, docs, tests; search codebase first to reuse existing patterns (https://docs.cursor.com/cookbook/reuse-existing-code).
- **Limitations**: Do not use AI solely for security-critical code, complex logic, or sensitive data. Validate outputs with tests/linting.
- **Review Protocol**: All AI-generated code must pass quality gates and peer review before merging.
- **Conflicts**: When user instructions explicitly contradict rules, follow user instructions and note the deviation. Rules guide defaults, not absolute constraints.
